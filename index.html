<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    body {
      background-color: rgb(250, 250, 250);
      color: rgb(255, 255, 255);
      font-family: 'Arial', sans-serif;
      width: 100%;
      margin: 0;
      font-size: 20px;
      overscroll-behavior: contain;
    }

    /* width */
    ::-webkit-scrollbar {
      width: 10px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      background: #1f1f1f;
    }

    /* Handle */
    ::-webkit-scrollbar-thumb {
      background: #333;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .navbar {
      overflow: hidden;
      background-color: #607d8b;
      z-index: 1;
      /* Sit on top */
      padding: 10px;
      color: white;
      position: fixed;
      /* Set the navbar to fixed position */
      top: 0;
      /* Position the navbar at the top of the page */
      width: 100%;
      /* Full width */
    }

    .content {
      margin-top: 55px
    }

    .group {
      float: none;
      box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
      clear: both;
      padding: 10px;
      margin: 20px 15px 10px 15px;
      overflow: auto;
      width: auto;
    }

    .group.muted {
      opacity: 0.27;
    }

    .groupheader {
      /* margin: 10px; */
      width: auto;
      height: fit-content;
      /* padding: 10px; */
      padding-bottom: 0px;
      display: grid;
      grid-template-columns: min-content auto min-content;
      grid-template-rows: min-content min-content;
      grid-gap: 0px;
    }

    .stream {
      /* background: violet; */
      color: #686868;
      grid-row: 1;
      grid-column: 1/3;
      width: auto;
    }

    select {
      background-color: transparent;
      border: 0px;
      width: 150px;
      font-size: 20px;
      color: #e3e3e3;
      -moz-appearance: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .mutebuttongroup {
      /* background: yellow; */
      color: #686868;
      grid-row: 2;
      grid-column: 1;
      font-size: 25px;
      /* padding: 3px; */
      text-decoration: none;
    }

    .slidergroupdiv {
      /* background: greenyellow; */
      display: flex;
      justify-content: center;
      align-items: center;
      grid-row: 2;
      grid-column: 2;
    }

    .client {
      /* text-align: left; */
      /* margin: 10px; */
      width: auto;
      height: fit-content;
      /* padding: 10px; */
      display: grid;
      grid-template-columns: min-content auto min-content;
      grid-template-rows: min-content min-content;
      grid-gap: 0px;
    }

    /* .client:hover {
    box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
} */

    .client.disconnected {
      opacity: 0.27;
    }

    .name {
      color: #686868;
      user-select: none;
      /* background: red; */
      padding-top: 5px;
      grid-row: 1;
      grid-column: 1/3;
      text-decoration: none;
    }

    .editdiv {
      background: violet;
      grid-row: 0/4;
      grid-column: 3;
    }

    .edit_icon {
      display: flex;
      /* background: blue; */
      color: #686868;
      align-items: center;
      grid-row: 1/3;
      grid-column: 3;
      text-decoration: none;
    }

    .edit_group_icon {
      display: flex;
      /* background: blue; */
      color: transparent;
      align-items: center;
      grid-row: 1/3;
      grid-column: 3;
      text-decoration: none;
    }

    .mutebutton {
      /* color: #444444; */
      color: #686868;
      grid-row: 2;
      grid-column: 1;
      font-size: 25px;
      height: 25px;
      /* padding: 3px; */
      text-decoration: none;
    }

    .sliderdiv {
      /* background: greenyellow; */
      display: flex;
      justify-content: center;
      align-items: center;
      grid-row: 2;
      grid-column: 2;
      /* padding-left: 40px; */
      /* display: inline-block;
    text-align: left;
    width: 250px; */
    }

    .slider {
      writing-mode: bt-lr;
      -webkit-appearance: none;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      -webkit-transition: .2s;
      transition: opacity .2s;
      height: 3px;
      width: 90%;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      height: 15px;
      width: 15px;
      border-radius: 50%;
      background: #ff4081;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      height: 15px;
      width: 15px;
      border-radius: 50%;
      background: #ff4081;
      cursor: pointer;
    }

    .slider.muted {
      opacity: 0.27;
    }

    .client_settings {
      display: none;
      /* Hidden by default */
      position: fixed;
      /* Stay in place */
      z-index: 1;
      /* Sit on top */
      left: 0;
      top: 0;
      width: 100%;
      /* Full width */
      height: 100%;
      /* Full height */
      overflow: auto;
      /* Enable scroll if needed */
      background-color: rgb(0, 0, 0);
      /* Fallback color */
      background-color: rgba(0, 0, 0, 0.4);
      /* Black w/ opacity */
    }

    .client_setting_content {
      background-color: #fefefe;
      color: #686868;
      margin: 15% auto;
      /* 15% from the top and centered */
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      /* Could be more or less, depending on screen size */
    }

    .client_input {
      color: #686868;
      width: 100%;
      padding: 12px 20px;
      margin: 8px 0;
      display: block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    input[type=submit] {
      width: 100%;
      background-color: #4CAF50;
      color: white;
      padding: 14px 20px;
      margin: 8px 0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    input[type=submit]:hover {
      background-color: #45a049;
    }

    div.container {
      border-radius: 5px;
      background-color: #f2f2f2;
      padding: 20px;
    }
  </style>
  <title>Snapcast Interface</title>
  <script>
    "use strict";
    class Host {
      constructor(json) {
        this.arch = "";
        this.ip = "";
        this.mac = "";
        this.name = "";
        this.os = "";
        this.fromJson(json);
      }
      fromJson(json) {
        this.arch = json.arch;
        this.ip = json.ip;
        this.mac = json.mac;
        this.name = json.name;
        this.os = json.os;
      }
    }
    class Client {
      constructor(json) {
        this.id = "";
        this.connected = false;
        this.fromJson(json);
      }
      fromJson(json) {
        this.id = json.id;
        this.host = new Host(json.host);
        let jsnapclient = json.snapclient;
        this.snapclient = { name: jsnapclient.name, protocolVersion: jsnapclient.protocolVersion, version: jsnapclient.version };
        let jconfig = json.config;
        this.config = { instance: jconfig.instance, latency: jconfig.latency, name: jconfig.name, volume: { muted: jconfig.volume.muted, percent: jconfig.volume.percent } };
        this.lastSeen = { sec: json.lastSeen.sec, usec: json.lastSeen.usec };
        this.connected = Boolean(json.connected);
      }
    }
    class Group {
      constructor(json) {
        this.name = "";
        this.id = "";
        this.stream_id = "";
        this.muted = false;
        this.clients = [];
        this.fromJson(json);
      }
      fromJson(json) {
        this.name = json.name;
        this.id = json.id;
        this.stream_id = json.stream_id;
        this.muted = Boolean(json.muted);
        for (let client of json.clients)
          this.clients.push(new Client(client));
      }
      getClient(id) {
        for (let client of this.clients) {
          if (client.id == id)
            return client;
        }
        return null;
      }
    }
    class Stream {
      constructor(json) {
        this.id = "";
        this.status = "";
        this.fromJson(json);
      }
      fromJson(json) {
        this.id = json.id;
        this.status = json.status;
        let juri = json.uri;
        this.uri = { raw: juri.raw, scheme: juri.scheme, host: juri.host, path: juri.path, fragment: juri.fragment, query: juri.query };
      }
    }
    class Server {
      constructor(json) {
        this.groups = [];
        this.streams = [];
        if (json)
          this.fromJson(json);
      }
      fromJson(json) {
        this.groups = [];
        for (let jgroup of json.groups)
          this.groups.push(new Group(jgroup));
        let jsnapserver = json.server.host;
        this.server = { host: new Host(json.server.host), snapserver: { controlProtocolVersion: jsnapserver.controlProtocolVersion, name: jsnapserver.name, protocolVersion: jsnapserver.protocolVersion, version: jsnapserver.version } };
        this.streams = [];
        for (let jstream of json.streams) {
          this.streams.push(new Stream(jstream));
        }
      }
      getClient(id) {
        for (let group of this.groups) {
          let client = group.getClient(id);
          if (client)
            return client;
        }
        return null;
      }
      getGroup(id) {
        for (let group of this.groups) {
          if (group.id == id)
            return group;
        }
        return null;
      }
      getStream(id) {
        for (let stream of this.streams) {
          if (stream.id == id)
            return stream;
        }
        return null;
      }
    }
    class SnapControl {
      constructor(host, port) {
        this.server = new Server();
        this.connection = new WebSocket('ws://' + host + ':' + port + '/jsonrpc');
        this.msg_id = 0;
        this.status_req_id = -1;
        this.connection.onmessage = (msg) => this.onMessage(msg.data);
        this.connection.onopen = (ev) => { this.status_req_id = this.sendRequest('Server.GetStatus'); };
        this.connection.onerror = (ev) => { alert("error: " + ev.type); }; //this.onError(ev);
      }
      action(answer) {
        switch (answer.method) {
          case 'Client.OnVolumeChanged':
            let client = this.getClient(answer.params.id);
            client.config.volume = answer.params.volume;
            updateGroupVolume(this.getGroupFromClient(client.id));
            break;
          case 'Client.OnLatencyChanged':
            this.getClient(answer.params.id).config.latency = answer.params.latency;
            break;
          case 'Client.OnNameChanged':
            this.getClient(answer.params.id).config.name = answer.params.name;
            break;
          case 'Client.OnConnect':
          case 'Client.OnDisconnect':
            this.getClient(answer.params.client.id).fromJson(answer.params.client);
            break;
          case 'Group.OnMute':
            this.getGroup(answer.params.id).muted = Boolean(answer.params.mute);
            break;
          case 'Group.OnStreamChanged':
            this.getGroup(answer.params.id).stream_id = answer.params.stream_id;
            break;
          case 'Stream.OnUpdate':
            this.getStream(answer.params.id).fromJson(answer.params.stream);
            break;
          case 'Server.OnUpdate':
            this.server.fromJson(answer.params.server);
            break;
          default:
            break;
        }
      }
      getClient(client_id) {
        return this.server.getClient(client_id);
      }
      getGroup(group_id) {
        return this.server.getGroup(group_id);
      }
      getGroupVolume(group) {
        if (group.clients.length == 0)
          return 0;
        let group_vol = 0;
        for (let client of group.clients) {
          group_vol += client.config.volume.percent;
        }
        return group_vol / group.clients.length;
      }
      getGroupFromClient(client_id) {
        for (let group of this.server.groups)
          for (let client of group.clients)
            if (client.id == client_id)
              return group;
        return null;
      }
      getStream(stream_id) {
        return this.server.getStream(stream_id);
      }
      setVolume(client_id, percent, mute) {
        percent = Math.max(0, Math.min(100, percent));
        let client = this.getClient(client_id);
        client.config.volume.percent = percent;
        if (mute != undefined)
          client.config.volume.muted = mute;
        this.sendRequest('Client.SetVolume', '{"id":"' + client_id + '","volume":{"muted":' + (client.config.volume.muted ? "true" : "false") + ',"percent":' + client.config.volume.percent + '}}');
      }
      setClientName(client_id, name) {
        let client = this.getClient(client_id);
        let current_name = (client.config.name != "") ? client.config.name : client.host.name;
        if (name != current_name) {
          this.sendRequest('Client.SetName', '{"id":"' + client_id + '","name":"' + name + '"}');
          client.config.name = name;
        }
      }
      setClientLatency(client_id, latency) {
        let client = this.getClient(client_id);
        let current_latency = client.config.latency;
        if (latency != current_latency) {
          this.sendRequest('Client.SetLatency', '{"id":"' + client_id + '","latency":' + latency + '}');
          client.config.latency = latency;
        }
      }
      setStream(group_id, stream_id) {
        this.getGroup(group_id).stream_id = stream_id;
        this.sendRequest('Group.SetStream', '{"id":"' + group_id + '","stream_id":"' + stream_id + '"}');
      }
      setClients(group_id, clients) {
        this.status_req_id = this.sendRequest('Group.SetClients', '{"clients":' + JSON.stringify(clients) + ',"id":"' + group_id + '"}');
      }
      muteGroup(group_id, mute) {
        this.getGroup(group_id).muted = mute;
        this.sendRequest('Group.SetMute', '{"id":"' + group_id + '","mute":' + (mute ? "true" : "false") + '}');
      }
      sendRequest(method, params) {
        let msg = '{"id": ' + (++this.msg_id) + ',"jsonrpc":"2.0","method":"' + method + '"';
        if (params)
          msg += ',"params": ' + params;
        msg += '}';
        console.log("Sending: " + msg);
        this.connection.send(msg);
        return this.msg_id;
      }
      onMessage(msg) {
        let answer = JSON.parse(msg);
        let is_response = (answer.id != undefined);
        console.log("Received " + (is_response ? "response" : "notification") + ", json: " + JSON.stringify(answer));
        if (is_response) {
          if (answer.id == this.status_req_id) {
            this.server = new Server(answer.result.server);
            show();
          }
        }
        else {
          if (Array.isArray(answer)) {
            for (let a of answer) {
              this.action(a);
            }
          }
          else {
            this.action(answer);
          }
          show();
        }
      }
    }
    let snapcontrol = new SnapControl(window.location.hostname, 1780);
    //let snapcontrol = new SnapControl("127.0.0.1", 1780);
    function show() {
      // Render the page
      let content = "";
      content += "<div class='navbar'>Snapcast";
      content += "</div>";
      content += "<div class='content'>";
      let server = snapcontrol.server;
      for (let group of server.groups) {
        // Set mute variables
        let classgroup;
        let muted;
        let mutetext;
        if (group.muted == true) {
          classgroup = 'group muted';
          muted = true;
          mutetext = '&#x1F507';
        }
        else {
          classgroup = 'group';
          muted = false;
          mutetext = '&#x1F50A';
        }
        // Start group div
        content += "<div id='g_" + group.id + "' class='" + classgroup + "'>";
        // Create stream selection dropdown
        let streamselect = "<select id='stream_" + group.id + "' onchange='setStream(\"" + group.id + "\")' class='stream'>";
        for (let i_stream = 0; i_stream < server.streams.length; i_stream++) {
          let streamselected = "";
          if (group.stream_id == server.streams[i_stream].id) {
            streamselected = 'selected';
          }
          streamselect += "<option value='" + server.streams[i_stream].id + "' " + streamselected + ">" + server.streams[i_stream].id + ": " + server.streams[i_stream].status + "</option>";
        }
        streamselect += "</select>";
        // Group mute and refresh button
        content += "<div class='groupheader'>";
        content += streamselect;
        if (group.clients.length > 1) {
          let volume = snapcontrol.getGroupVolume(group);
          content += "<a href=\"javascript:setMuteGroup('" + group.id + "'," + !muted + ");\" class='mutebuttongroup'>" + mutetext + "</a>";
          content += "<div class='slidergroupdiv'>";
          content += "    <input type='range' draggable='false' min=0 max=100 step=1 id='vol_" + group.id + "' oninput='javascript:setGroupVolume(\"" + group.id + "\")' value=" + volume + " class='slider'>";
          // content += "    <input type='range' min=0 max=100 step=1 id='vol_" + group.id + "' oninput='javascript:setVolume(\"" + client.id + "\"," + client.config.volume.muted + ")' value=" + client.config.volume.percent + " class='" + sliderclass + "'>";
          content += "</div>";
        }
        // transparent placeholder edit icon
        content += "<div class='edit_group_icon'>&#9998</div>";
        content += "</div>";
        content += "<hr style=\"height:2px;border-width:0px;color:lightgray;background-color:lightgray\">";
        // Create clients in group
        for (let client of group.clients) {
          // Set name and connection state vars, start client div
          let name;
          let clas = 'client';
          if (client.config.name != "") {
            name = client.config.name;
          }
          else {
            name = client.host.name;
          }
          if (client.connected == false) {
            clas = 'client disconnected';
          }
          content += "<div id='c_" + client.id + "' class='" + clas + "'>";
          // Client mute status vars
          let muted;
          let sliderclass;
          if (client.config.volume.muted == true) {
            muted = true;
            sliderclass = 'slider muted';
            mutetext = '&#x1F507';
          }
          else {
            sliderclass = 'slider';
            muted = false;
            mutetext = '&#x1F50A';
          }
          // Populate client div
          content += "<a href=\"javascript:setVolume('" + client.id + "'," + !muted + ");\" class='mutebutton'>" + mutetext + "</a>";
          content += "    <div class='sliderdiv'>";
          content += "        <input type='range' min=0 max=100 step=1 id='vol_" + client.id + "' oninput='javascript:setVolume(\"" + client.id + "\"," + client.config.volume.muted + ")' value=" + client.config.volume.percent + " class='" + sliderclass + "'>";
          content += "    </div>";
          content += "    <a href=\"javascript:open_client_settings('" + client.id + "');\" class='edit_icon'>&#9998</a>";
          content += "    <div class='name'>" + name + "</div>";
          content += "</div>";
        }
        content += "</div>";
      }
      content += "</div>"; // content
      content += "<div id='client_settings' class='client_settings'>";
      content += "    <div class='client_setting_content'>";
      content += "        <form action='javascript:close_client_settings()'>";
      content += "        <label for='client_name'>Name</label>";
      content += "        <input type='text' class='client_input' id='client_name' name='client_name' placeholder='Client name..'>";
      content += "        <label for='client_latency'>Latency</label>";
      content += "        <input type='number' class='client_input' min='-1000' max='1000' id='client_latency' name='client_latency' placeholder='Latency in ms..'>";
      content += "        <label for='client_group'>Group</label>";
      content += "        <select id='client_group' class='client_input' name='client_group'>";
      content += "        </select>";
      content += "        <input type='submit' value='Submit'>";
      content += "        </form>";
      content += "    </div>";
      content += "</div>";
      // Pad then update page
      content = content + "<br><br>";
      document.getElementById('show').innerHTML = content;
      for (let group of snapcontrol.server.groups) {
        if (group.clients.length > 1) {
          let slider = document.getElementById("vol_" + group.id);
          slider.addEventListener('pointerdown', function (ev) {
            groupVolumeEnter(group.id);
          });
        }
      }
    }
    function updateGroupVolume(group) {
      let group_vol = snapcontrol.getGroupVolume(group);
      let slider = document.getElementById("vol_" + group.id);
      if (slider == null)
        return;
      console.log("updateGroupVolume group: " + group.id + ", volume: " + group_vol + ", slider: " + (slider != null));
      slider.value = String(group_vol);
    }
    let client_volumes;
    let group_volume;
    function setGroupVolume(group_id) {
      let group = snapcontrol.getGroup(group_id);
      let percent = document.getElementById('vol_' + group.id).valueAsNumber;
      console.log("setGroupVolume id: " + group.id + ", volume: " + percent);
      // show()
      let delta = percent - group_volume;
      let ratio;
      if (delta < 0)
        ratio = (group_volume - percent) / group_volume;
      else
        ratio = (percent - group_volume) / (100 - group_volume);
      for (let i = 0; i < group.clients.length; ++i) {
        let new_volume = client_volumes[i];
        if (delta < 0)
          new_volume -= ratio * client_volumes[i];
        else
          new_volume += ratio * (100 - client_volumes[i]);
        let client_id = group.clients[i].id;
        // TODO: use batch request to update all client volumes at once
        snapcontrol.setVolume(client_id, new_volume);
        let slider = document.getElementById('vol_' + client_id);
        slider.value = String(new_volume);
      }
    }
    function groupVolumeEnter(group_id) {
      let group = snapcontrol.getGroup(group_id);
      let percent = document.getElementById('vol_' + group.id).valueAsNumber;
      console.log("groupVolumeEnter id: " + group.id + ", volume: " + percent);
      group_volume = percent;
      client_volumes = [];
      for (let i = 0; i < group.clients.length; ++i) {
        client_volumes.push(group.clients[i].config.volume.percent);
      }
      // show()
    }
    function setVolume(id, mute) {
      console.log("setVolume id: " + id + ", mute: " + mute);
      let percent = document.getElementById('vol_' + id).valueAsNumber;
      let client = snapcontrol.getClient(id);
      let needs_update = (mute != client.config.volume.muted);
      snapcontrol.setVolume(id, percent, mute);
      let group = snapcontrol.getGroupFromClient(id);
      updateGroupVolume(group);
      if (needs_update)
        show();
    }
    function setMuteGroup(id, mute) {
      snapcontrol.muteGroup(id, mute);
      show();
    }
    function setStream(id) {
      snapcontrol.setStream(id, document.getElementById('stream_' + id).value);
      show();
    }
    function setGroup(client_id, group_id) {
      console.log("setGroup id: " + client_id + ", group: " + group_id);
      let server = snapcontrol.server;
      // Get client group id
      let current_group = snapcontrol.getGroupFromClient(client_id);
      // Get
      //   List of target group's clients
      // OR
      //   List of current group's other clients
      let send_clients = [];
      for (let i_group = 0; i_group < server.groups.length; i_group++) {
        if (server.groups[i_group].id == group_id || (group_id == "new" && server.groups[i_group].id == current_group.id)) {
          for (let i_client = 0; i_client < server.groups[i_group].clients.length; i_client++) {
            if (group_id == "new" && server.groups[i_group].clients[i_client].id == client_id) { }
            else {
              send_clients[send_clients.length] = server.groups[i_group].clients[i_client].id;
            }
          }
        }
      }
      if (group_id == "new")
        group_id = current_group.id;
      else
        send_clients[send_clients.length] = client_id;
      snapcontrol.setClients(group_id, send_clients);
    }
    function setName(id) {
      // Get current name and lacency
      let client = snapcontrol.getClient(id);
      let current_name = (client.config.name != "") ? client.config.name : client.host.name;
      let current_latency = client.config.latency;
      let new_name = window.prompt("New Name", current_name);
      let new_latency = Number(window.prompt("New Latency", String(current_latency)));
      if (new_name != null)
        snapcontrol.setClientName(id, new_name);
      if (new_latency != null)
        snapcontrol.setClientLatency(id, new_latency);
      show();
    }
    function open_client_settings(id) {
      let modal = document.getElementById("client_settings");
      let client = snapcontrol.getClient(id);
      let current_name = (client.config.name != "") ? client.config.name : client.host.name;
      let name = document.getElementById("client_name");
      name.name = id;
      name.value = current_name;
      let latency = document.getElementById("client_latency");
      latency.valueAsNumber = client.config.latency;
      let group = snapcontrol.getGroupFromClient(id);
      let group_input = document.getElementById("client_group");
      while (group_input.length > 0)
        group_input.remove(0);
      let group_num = 0;
      for (let ogroup of snapcontrol.server.groups) {
        let option = document.createElement('option');
        option.value = ogroup.id;
        option.text = "Group " + (group_num + 1) + " (" + ogroup.clients.length + " Clients)";
        group_input.add(option);
        if (ogroup == group) {
          console.log("Selected: " + group_num);
          group_input.selectedIndex = group_num;
        }
        ++group_num;
      }
      let option = document.createElement('option');
      option.value = option.text = "new";
      group_input.add(option);
      modal.style.display = "block";
    }
    function close_client_settings() {
      let name = document.getElementById("client_name");
      let id = name.name;
      console.log("onclose " + id + ", value: " + name.value);
      snapcontrol.setClientName(id, name.value);
      let latency = document.getElementById("client_latency");
      snapcontrol.setClientLatency(id, latency.valueAsNumber);
      let group_input = document.getElementById("client_group");
      let option = group_input.options[group_input.selectedIndex];
      setGroup(id, option.value);
      let modal = document.getElementById("client_settings");
      modal.style.display = "none";
      show();
    }
    // When the user clicks anywhere outside of the modal, close it
    window.onclick = function (event) {
      let modal = document.getElementById("client_settings");
      if (event.target == modal) {
        modal.style.display = "none";
      }
    };
//# sourceMappingURL=script.js.map
  </script>
</head>

<body>
  <div id="show"></div>
</body>

</html>